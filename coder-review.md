- GetCartController убрал пробел в условии ! $cart. Хотя эта проверка неверная, так как getCart всегда возвращает корзину, поэтому в условии всегда будет false. Добавил вместо этого проверку на getItems
- Так же в GetCartController есть такой момент, что не важно есть корзина или ее нет, всегда возвращается статус 404, вернем 200 в случае когда корзина имеется
- GetProductsController всегда возвращал 200, вслучае если не была бы передана категория, была бы ошибка. Добавил проверку на категорию и при ее отсутствии - 400. Так же исправил опечатку в productsView
- CartManager: Убрал наследование от ConnectorFacade и перешел на внедрение зависимостей. Код таким образом более гибкий. Также я исправил конструктор метода getCart(), чтобы он всегда возвращал полноценный объект Cart, даже если корзина не была найдена. И, конечно, поменял местами аргументы в saveCart() для правильной работы с коннектором. А так же поправил лгирование, чтобы была запись о конкретной ошибке
- AddToCartController: После добавления нового товара в корзину я добавил вызов $this->cartManager->saveCart($cart);. Без него все изменения терялись бы после завершения запроса.
- ConnectorFacade: catch пустой, что является плохой практикой
- Исправил конструктор в Connector, для корректного присваения объекта Redis
- get и set в Connector имели несогласованность в $key, исправил на string с Cart объекта
- Connector теперь передается в CartManager.
- В запросах CartRepository передавалось через конкатенацию значения, нужно через :params для защиты от SQL инъекции
- Разделение ответственность - CartManager и ProductRepository теперь реализуют интерфейсы, определенные в слое Domain.
- Ошибка при подсчете общей стоимости корзины
- Из View убрал запрос к данным, так как он должен только их отображать
- Интерфейсы CartManagerInterface и ProductRepositoryInterface, чтобы бизнес логика не зависела от того, где и как хранятся данные
- AddToCartController и GetCartController теперь зависят от ProductRepositoryInterface и CartManagerInterface для более легкой замены реализации, так сказать - инверсия зависимостей

Пояснения к текущей структуре:
- Слой Domain содержит бизнес логику, которая не зависит от того, где и как хранятся данные, поэтому мы можем заменить реализацию без влияния на бизнес логику
- Слой Infrastructure содержит детали реализации, он реализует контракты определенные в бизнес логике. Данный слой взаимодействует с БД и Redis
- CartManagerInterface и ProductRepositoryInterface - это контракты для работы с хранилизем
- Product - DTO
- Connector, ConnectorFacade, ConnectorException - вспомогательные классы для работы с Redis
- Слой View отвечает только за преобразование данных, только их форматирование, не содержит бизнес логику. 
- Controllers - точка входа для внешних запросов

С такой структурой теперь можно написать тесты, например для ProductRepository без запуска всего приложения или протестироват AddToCartController, замокав репозитории